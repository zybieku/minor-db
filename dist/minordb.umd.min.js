(function(d,u){typeof exports=="object"&&typeof module!="undefined"?module.exports=u():typeof define=="function"&&define.amd?define(u):(d=typeof globalThis!="undefined"?globalThis:d||self,d.MinorDB=u())})(this,function(){"use strict";var D=Object.defineProperty;var q=(d,u,w)=>u in d?D(d,u,{enumerable:!0,configurable:!0,writable:!0,value:w}):d[u]=w;var c=(d,u,w)=>(q(d,typeof u!="symbol"?u+"":u,w),w);const d=m=>typeof m=="object"&&m!==null,u=m=>m.target.error,w=m=>{throw new Error(m)},b=m=>{throw new TypeError(m)},k=window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB,g=window.IDBKeyRange||window.webkitIDBKeyRange||window.msIDBKeyRange,B={"<":"upperBound",">":"lowerBound"},O={ASC:"next",DESC:"prev"};class _{constructor(e){c(this,"_table");c(this,"whereCause");c(this,"find");c(this,"remove");this._table=e,this.whereCause={orderBy:"next"},this.find=()=>this._table.find(this.whereCause),this.remove=()=>this._table.remove(this.whereCause)}where(e){if(!d(e))return this;const t=Object.keys(e);if(t.length===1){let r=t[0];this.whereCause.field=r;const s=e[r],n=Object.keys(s);for(const i of n){let p=s[i];if(i==="=")return this.whereCause.keyRange=g.only(p),this;const o=!i.endsWith("="),a=o?i:i.slice(0,1);let f=this.whereCause.keyRange;if(f){let{lower:h,upper:l,lowerOpen:y,upperOpen:C}=f;return h?(l=p,C=o):(h=p,y=o),h>=l&&w("lower must to less than upper value"),this.whereCause.keyRange=g.bound(h,l,y,C),this}this.whereCause.keyRange=g[B[a]](p,o)}}return this}sort(e="ASC"){const t=O[e.toUpperCase()];return t||w("The value of param must be DESC or ASC"),this.whereCause.orderBy=t,this}limit(e){return Number.isInteger(e)||w("param type must be an int"),this.whereCause.count=e,this}update(e){const{field:t,count:r,keyRange:s,orderBy:n}=this.whereCause;return new Promise((i,p)=>{const o=this._table.getStore("readwrite");let a=o.keyPath,f=!t||a===t?o.openCursor(s,n):o.index(t).openCursor(s,n);const h=[];f.onsuccess=l=>{const y=l.target.result;if(y){if(e[a]=y.primaryKey,y.update(e),h.push(y.primaryKey),r&&h.length>=r){i(h);return}y.continue()}else i(h)},f.onerror=l=>p(u(l))})}}class R{constructor(e,t){c(this,"minorDb");c(this,"_name");c(this,"_pkey","");c(this,"where");c(this,"limit");c(this,"sort");this.minorDb=e,this._name=t,this.where=r=>new _(this).where(r),this.limit=r=>new _(this).limit(r),this.sort=r=>new _(this).sort(r)}get idb(){return this.minorDb._idb}create(e){const t=e.split(","),r=t[0].trim(),s=r.startsWith("++");this._pkey=s?r.slice(2):r;const n={keyPath:this._pkey,autoIncrement:s},i=this.idb.createObjectStore(this._name,n);if(!(t.length<=1))for(let p=1;p<t.length;p++){const o=t[p].trim(),a=o.startsWith("&"),f=a?o.slice(1):o;i.createIndex(f,f,{unique:a})}}getStore(e){var t;return this.minorDb.isOpen||w("the indexdb is not open"),(t=this.idb)==null?void 0:t.transaction([this._name],e).objectStore(this._name)}insert(e){d(e)||b("content must be is an object or array ");const t=this.getStore("readwrite");return Array.isArray(e)?Promise.all(e.map(r=>this.insertOne(r,t))):this.insertOne(e,t)}insertOne(e,t){return(!d(e)||Array.isArray(e))&&b("content must be is an object"),new Promise((r,s)=>{t||(t=this.getStore("readwrite"));const n=t.add(e);n.onsuccess=()=>{r(n.result)},n.onerror=i=>s(u(i))})}update(e){return(!d(e)||Array.isArray(e))&&b("content must be is an object"),new Promise((t,r)=>{const s=this.getStore("readwrite");e[s.keyPath]||r("content must have a primary key");const n=s.put(e);n.onsuccess=()=>t(n.result),n.onerror=i=>r(u(i))})}find(e={}){const{field:t,count:r,keyRange:s,orderBy:n}=e;return new Promise((i,p)=>{const o=this.getStore("readonly"),a=[];let f=!t||o.keyPath===t?o.openCursor(s,n):o.index(t).openCursor(s,n);f.onsuccess=h=>{const l=h.target.result;if(l){if(a.push(l.value),r&&a.length>=r)return i(a),a;l.continue()}else i(a)},f.onerror=h=>p(u(h))})}remove(e={}){d(e)||b("whereCause must be an object ");const{field:t,count:r,keyRange:s,orderBy:n}=e;return new Promise((i,p)=>{const o=this.getStore("readwrite"),a=[];let f=!t||o.keyPath===t?o.openCursor(s,n):o.index(t).openCursor(s,n);f.onsuccess=h=>{const l=h.target.result;if(l){if(a.push(l.value),l.delete(),r&&a.length>=r){i(a);return}l.continue()}else i(a)},f.onerror=h=>p(u(h))})}clear(){return new Promise((e,t)=>{const r=this.getStore("readwrite").clear();r.onsuccess=()=>e(r.result),r.onerror=s=>t(u(s))})}}class S{constructor(e,t){c(this,"_name");c(this,"_version");c(this,"_isOpen",!1);c(this,"request");c(this,"_idb");c(this,"upgradeFunc");return this._name=e,this._version=t||1,this}get name(){return this._name}get version(){return this._version}get isOpen(){return this._isOpen}onupgradeneeded(e){this.upgradeFunc=e}open(e){return this.close(),this._stores(e),new Promise((t,r)=>{this.request=k.open(this._name,this._version),this.request.onupgradeneeded=s=>{this._idb=s.target.result,this._addStores(e),this.upgradeFunc&&this.upgradeFunc(s),console.log("onupgradeneeded")},this.request.onsuccess=s=>{this._idb=s.target.result,this._isOpen=!0,t(s)},this.request.onerror=s=>r(u(s))})}_addStores(e){for(const t of Object.keys(e))this._idb.objectStoreNames.contains(t)||this[t].create(e[t])}_stores(e){if(!d(e))throw new Error("schemas required an  Object");for(const t of Object.keys(e)){if(this[t])break;this[t]=new R(this,t)}return this}getTableNames(){return this._idb&&this._idb.objectStoreNames}close(){var e;this._isOpen&&((e=this._idb)==null||e.close(),this._isOpen=!1,this._idb=void 0)}drop(){return this.close(),new Promise((e,t)=>{const r=k.deleteDatabase(this._name);r.onsuccess=s=>e(s),r.onerror=s=>t(s)})}}return S});
