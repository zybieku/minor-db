!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("MinorDB",[],t):"object"==typeof exports?exports.MinorDB=t():e.MinorDB=t()}(self,(function(){return(()=>{"use strict";var e={d:(t,r)=>{for(var s in r)e.o(r,s)&&!e.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:r[s]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};e.d(t,{default:()=>l});const r=e=>"object"==typeof e&&null!==e,s=e=>e.target.error,n=e=>{throw new Error(e)},o=e=>{throw new TypeError(e)},i=window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB,a=window.IDBKeyRange||window.webkitIDBKeyRange||window.msIDBKeyRange,u={"<":"upperBound",">":"lowerBound"},h={ASC:"next",DESC:"prev"};class c{_table;whereCause;find;remove;constructor(e){this._table=e,this.whereCause={orderBy:"next"},this.find=()=>this._table.find(this.whereCause),this.remove=()=>this._table.remove(this.whereCause)}where(e){if(!r(e))return this;const t=Object.keys(e);if(1===t.length){let r=t[0];this.whereCause.field=r;const s=e[r],o=Object.keys(s);for(const e of o){let t=s[e];if("="===e)return this.whereCause.keyRange=a.only(t),this;const r=!e.endsWith("="),o=r?e:e.slice(0,1);let i=this.whereCause.keyRange;if(i){let{lower:e,upper:s,lowerOpen:o,upperOpen:u}=i;return e?(s=t,u=r):(e=t,o=r),e>=s&&n("lower must to less than upper value"),this.whereCause.keyRange=a.bound(e,s,o,u),this}this.whereCause.keyRange=a[u[o]](t,r)}}return this}sort(e="ASC"){const t=h[e.toUpperCase()];return t||n("The value of param must be DESC or ASC"),this.whereCause.orderBy=t,this}limit(e){return Number.isInteger(e)||n("param type must be an int"),this.whereCause.count=e,this}update(e){const{field:t,count:r,keyRange:n,orderBy:o}=this.whereCause;return new Promise(((i,a)=>{const u=this._table.getStore("readwrite");let h=u.keyPath,c=t&&h!==t?u.index(t).openCursor(n,o):u.openCursor(n,o);const d=[];c.onsuccess=t=>{const s=t.target.result;if(s){if(e[h]=s.primaryKey,s.update(e),d.push(s.primaryKey),r&&d.length>=r)return void i(d);s.continue()}else i(d)},c.onerror=e=>a(s(e))}))}}class d{minorDb;_name;_pkey="";where;limit;sort;constructor(e,t){this.minorDb=e,this._name=t,this.where=e=>new c(this).where(e),this.limit=e=>new c(this).limit(e),this.sort=e=>new c(this).sort(e)}get idb(){return this.minorDb._idb}create(e){const t=e.split(","),r=t[0].trim(),s=r.startsWith("++");this._pkey=s?r.slice(2):r;const n={keyPath:this._pkey,autoIncrement:s},o=this.idb.createObjectStore(this._name,n);if(!(t.length<=1))for(let e=1;e<t.length;e++){const r=t[e].trim(),s=r.startsWith("&"),n=s?r.slice(1):r;o.createIndex(n,n,{unique:s})}}getStore(e){return this.minorDb.isOpen||n("the indexdb is not open"),this.idb?.transaction([this._name],e).objectStore(this._name)}insert(e){r(e)||o("content must be is an object or array ");const t=this.getStore("readwrite");return Array.isArray(e)?Promise.all(e.map((e=>this.insertOne(e,t)))):this.insertOne(e,t)}insertOne(e,t){return r(e)&&!Array.isArray(e)||o("content must be is an object"),new Promise(((r,n)=>{t||(t=this.getStore("readwrite"));const o=t.add(e);o.onsuccess=()=>{r(o.result)},o.onerror=e=>n(s(e))}))}update(e){return r(e)&&!Array.isArray(e)||o("content must be is an object"),new Promise(((t,r)=>{const n=this.getStore("readwrite");e[n.keyPath]||r("content must have a primary key");const o=n.put(e);o.onsuccess=()=>t(o.result),o.onerror=e=>r(s(e))}))}find(e={}){const{field:t,count:r,keyRange:n,orderBy:o}=e;return new Promise(((e,i)=>{const a=this.getStore("readonly"),u=[];let h=t&&a.keyPath!==t?a.index(t).openCursor(n,o):a.openCursor(n,o);h.onsuccess=t=>{const s=t.target.result;if(s){if(u.push(s.value),r&&u.length>=r)return void e(u);s.continue()}else e(u)},h.onerror=e=>i(s(e))}))}remove(e={}){r(e)||o("whereCause must be an object ");const{field:t,count:n,keyRange:i,orderBy:a}=e;return new Promise(((e,r)=>{const o=this.getStore("readwrite"),u=[];let h=t&&o.keyPath!==t?o.index(t).openCursor(i,a):o.openCursor(i,a);h.onsuccess=t=>{const r=t.target.result;if(r){if(u.push(r.value),r.delete(),n&&u.length>=n)return void e(u);r.continue()}else e(u)},h.onerror=e=>r(s(e))}))}clear(){return new Promise(((e,t)=>{const r=this.getStore("readwrite").clear();r.onsuccess=()=>e(r.result),r.onerror=e=>t(s(e))}))}}const l=class{_name;_version;_isOpen=!1;request;_idb;upgradeFunc;constructor(e,t){return this._name=e,this._version=t||1,this}get name(){return this._name}get version(){return this._version}get isOpen(){return this._isOpen}onupgradeneeded(e){this.upgradeFunc=e}open(e){return this.close(),this._stores(e),new Promise(((t,r)=>{this.request=i.open(this._name,this._version),this.request.onupgradeneeded=t=>{this._idb=t.target.result,this._addStores(e),this.upgradeFunc&&this.upgradeFunc(t)},this.request.onsuccess=e=>{this._idb=e.target.result,this._isOpen=!0,t(e)},this.request.onerror=e=>r(s(e))}))}_addStores(e){for(const t of Object.keys(e))this._idb.objectStoreNames.contains(t)||this[t].create(e[t])}_stores(e){if(!r(e))throw new Error("schemas required an  Object");for(const t of Object.keys(e)){if(this[t])break;this[t]=new d(this,t)}return this}getTableNames(){return this._idb&&this._idb.objectStoreNames}close(){this._isOpen&&(this._idb?.close(),this._isOpen=!1,this._idb=void 0)}drop(){return this.close(),new Promise(((e,t)=>{const r=i.deleteDatabase(this._name);r.onsuccess=t=>e(t),r.onerror=e=>t(e)}))}};return t.default})()}));