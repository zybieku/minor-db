!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("MinorDB",[],t):"object"==typeof exports?exports.MinorDB=t():e.MinorDB=t()}(self,(function(){return(()=>{"use strict";var e={d:(t,r)=>{for(var s in r)e.o(r,s)&&!e.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:r[s]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};e.d(t,{default:()=>d});const r=e=>"object"==typeof e&&null!==e,s=e=>e.target.error,n=e=>{throw new Error(e)},o=window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB,i=window.IDBKeyRange||window.webkitIDBKeyRange||window.msIDBKeyRange,a={"<":"upperBound",">":"lowerBound"},c={ASC:"next",DESC:"prev"};class h{constructor(e){this._table=e,this.whereCause={orderBy:"next"},this._bind()}where(e){if(!r(e))return this;const t=Object.keys(e);return 1===t.length&&t.forEach((t=>{const r=e[t],s=Object.keys(r);1===s.length&&s.forEach((e=>{const t=!e.endsWith("="),s=t?e:e.slice(0,1);this.whereCause.keyRange=i[a[s]](r[e],t)}))})),this}sort(){const e=c[(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"ASC").toUpperCase()];return e||n("The value of param must be DESC or ASC"),this.whereCause.orderBy=e,this}limit(e){return Number.isInteger(e)||n("param type must be an int"),this.whereCause.count=e,this}_bind(){["find","remove"].forEach((e=>{this[e]=t=>this._table[e](t,this.whereCause)}))}}class u{constructor(e,t){this.minorDb=e,this._name=t,this._bind()}get idb(){return this.minorDb._idb}create(e){const t=e.split(","),r=t[0].trim(),s=r.startsWith("++");this._pkey=s?r.slice(2):r;const n={keyPath:this._pkey,autoIncrement:s},o=this.idb.createObjectStore(this._name,n);if(!(t.length<=1))for(let e=1;e<t.length;e++){const r=t[e].trim(),s=r.startsWith("&"),n=s?r.slice(1):r;o.createIndex(n,n,{unique:s})}}getStore(e){return this.idb.transaction([this._name],e).objectStore(this._name)}_bind(){var e=this;["where","limit","sort"].forEach((t=>{this[t]=function(){return new h(e)[t](...arguments)}}))}insert(e){return r(e)||n("content must be is an object or array "),Array.isArray(e)?Promise.all(e.map((e=>this.insertOne(e)))):this.insertOne(e)}insertOne(e){return r(e)&&!Array.isArray(e)||n("content must be is an object"),new Promise(((t,r)=>{const n=this.getStore("readwrite").add(e);n.onsuccess=()=>{t(n.result)},n.onerror=e=>r(s(e))}))}update(e){return r(e)&&!Array.isArray(e)||n("content must be is an object"),new Promise(((t,r)=>{const n=this.getStore("readwrite");e[n.keyPath]||r("content must have a primary key");const o=n.put(e);o.onsuccess=()=>t(o.result),o.onerror=e=>r(s(e))}))}find(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{count:r,keyRange:n,orderBy:o}=t;return new Promise(((e,t)=>{const i=this.getStore("readonly"),a=[],c=i.openCursor(n,o);c.onsuccess=t=>{const s=t.target.result;if(s){if(a.push(s.value),r&&a.length>=r)return void e(a);s.continue()}else e(a)},c.onerror=e=>t(s(e))}))}remove(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};r(e)&&!Array.isArray(e)||n("whereCause must be an object ");const{count:t,keyRange:o,orderBy:i}=e;return new Promise(((e,r)=>{const n=this.getStore("readwrite");console.log(n);const a=n.openCursor(o,i),c=[];a.onsuccess=r=>{const s=r.target.result;if(s){if(t&&c.length>=t)return void e(c);s.delete(),c.push(s.value),s.continue()}else e(c)},a.onerror=e=>r(s(e))}))}clear(){return new Promise(((e,t)=>{const r=this.getStore("readwrite").clear();r.onsuccess=()=>e(r.result),r.onerror=e=>t(s(e))}))}}const d=class{constructor(e,t){this._name=e,this._version=t||1}get name(){return this._name}get version(){return this._version}onupgradeneeded(e){this.upgradeFunc=e}open(e){return this.close(),this._stores(e),new Promise(((t,r)=>{this.request=o.open(this._name,this._version),this.request.onupgradeneeded=t=>{this._idb=t.target.result,this._addStores(e),this.upgradeFunc&&this.upgradeFunc(t)},this.request.onsuccess=e=>{this._idb=e.target.result,this._isOpen=!0,t(e)},this.request.onerror=e=>r(s(e))}))}_addStores(e){for(const t of Object.keys(e))this._idb.objectStoreNames.contains(t)||this[t].create(e[t])}_stores(e){if(!r(e))throw new Error("schemas required an  Object");for(const t of Object.keys(e)){if(this[t])break;this[t]=new u(this,t,e[t])}return this}getTableNames(){return this._idb&&this._idb.objectStoreNames}close(){this._isOpen&&(this._idb.close(),this._isOpen=!1,this._idb=null)}drop(){return this.close(),new Promise(((e,t)=>{const r=o.deleteDatabase(this._name);r.onsuccess=()=>e(),r.onerror=e=>t(e)}))}};return t.default})()}));